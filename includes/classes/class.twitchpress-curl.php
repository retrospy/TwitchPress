<?php
/**
 * General Curl class that extends WP_Http_Curl 
 * 
 * Use: $this->curl_object = new TwitchPress_Curl(); 
 * 
 * Do so in a function or a class like class.twitch-api.php  
 *
 * @class    TwitchPress_Curl
 * @version  1.0
 * @package  TwitchPress/ Classes
 * @category Class
 * @author   Ryan Bayne
 * 
 * See class.twitchpress-extend-wp-http-curl.php for an alternative approach.
 */

if ( ! defined( 'ABSPATH' ) ) {
    exit;
}

class TwitchPress_Curl extends WP_Http_Curl {
    
    private $WP_Http_Curl_Object = null;
    
    public $headers = array();
    
    /**
    * All variables will be placed into one array.
    * 
    * @var array
    */
    private $call_parameters = array(); 

    /**
    * Call count option "twitchpress_twitchapi_call_count" doubles
    * as a call ID.
    * 
    * @var mixed
    */
    private $call_id = 0;
    
    /**
    * ID for tracing a sequence of log entries. The logging ID
    * becomes entry ID in class.twitchpresS_api_logging.php and
    * applicable database tables...
    * 
    * @var int - incremental ID generated by MySQL on the first logging INSERT
    */
    public $loggingid = null;
    
    /**
    * get, put, delete, post
    * 
    * @var mixed
    */
    public $type = 'unset';
    
    /**
    * The endpoint to be called.
    * 
    * @var string
    */
    public $endpoint = 'https://api.twitch.tv/helix/games/top'; 
    
    public $scope = null;
    
    /**
    * Can this call be cached? 
    * 
    * @var boolean
    */
    public $can_cache = false;
    
    /**
    * Cache storage time limit in seconds.
    * 
    * @var integer
    */
    public $cache_time = 120;
    
    /**
    * Use to tell TwitchPress to queue a request if the system is busy. 
    * Basically rendering the request a background operation. 
    * 
    * We have the class to do this properly! 
    * 
    * @var mixed
    */
    public $can_queue = false;
    
    /**
    * API name will be used for accessing the correct API endpoints.
    * 
    * @var string
    */
    public $api_name = 'twitch';
    
    /**
    * If call related to a WP user this is the WP user ID.
    * 
    * @var integer
    */
    public $giving_user = null;
    
    /**
    * WP user ID if the visitor is logged in.
    * 
    * @var integer
    */
    public $current_user = null;
    
    /**
    * Is the call being done for a specific WP user?
    * 
    * @var boolean 
    */
    public $user_specific = false;
    
    /**
    * If call fails should we try again?
    * 
    * @var boolean 
    */
    public $retry = false;
    
    /**
    * Servers version of curl
    * 
    * @var mixed
    */
    public $curl_version = null;
      
    /**
    * Call request within body included: method,body,user-agent,stream,filename,decompress
    * 
    * @var array      
    */
    public $curl_request = array();
    
    /**
    * The request body array as added to the parent request array.
    * 
    * @var array
    */
    public $curl_request_body = array();

    /**
    * The raw curl reply.
    * 
    * @var array
    */
    public $curl_reply = array(); 
    
    /**
    * Curl reply body after json_decode()
    * 
    * @var mixed
    */
    public $curl_reply_body = array();
    
    /**
    * The response value of a curl reply.
    * 
    * @var array
    */
    public $curl_reply_response = array();
    
    public $transient_name = null;
    
    /**
    * The code taking from the response array within the complete reply.
    * 
    * @var mixed
    */
    public $response_code = null;
    
    /**
    * The message taking from the response array within the complete reply.
    * 
    * @var mixed
    */
    public $response_message = null;
    
    public $originating_file = 'Unknown';
    
    public $originating_function = 'Unknown';

    public $originating_line = 'Unknown';
    
    public $refresh_token = null;
    
    /**
    * put your comment there...
    * 
    * @var boolean
    */
    public $paginate = false;
    public $pagination_array = array(); 
    
    public function __construct() {
        $this->curl_version = curl_version();
        $this->current_user = get_current_user_id();
    }   
         
    /**
    * Required method when making a WP_Http_Curl call.
    * 
    * This one contains all available parameters to guide developers.
    * 
    * @uses WP_Http_Curl() 
    * @uses curl_version() 
    *            
    * @version 3.0
    */    
    public function do_call( $optional_args = array() ) {
        // Establish a call ID that can be used in logs...
        $this->call_id = twitchpress_get_new_call_id(); 
                  
        // Create the WordPress Http Curl object
        $this->WP_Http_Curl_Object = new WP_Http_Curl();
                                 
        // Set defaults...
        $this->parse_arguments( $optional_args );// Uses wp_parse_args()   

        // Check for a transient cache...
        $there_was_a_cache = false;
        if( $this->can_cache )
        {        
            $there_was_a_cache = $this->get_transient();
        }
      
        if( !$there_was_a_cache ) {
            $this->call_execute(); 
        }               
    }
        
    /**
    * Optional function offering all parameters when making a WP_Http_Curl 
    * call within the TwitchPress system. Use this to learn which values are available
    * and then pass the returned array to call_start() as the $optional_args value.
    * 
    * Any arguments not made will initially be populated by this classes defaults
    * but later we might have options that over-ride in-line defaults. 
    * 
    * @uses WP_Http_Curl() 
    * @uses curl_version()
    * 
    * @since 2.5.0
    * @version 3.0
    */    
    public function call_params( $can_cache = null, $cache_time = null, $can_queue = null, $giving_user = null, $user_specific = null, $retry = null, $originating_function = null, $originating_line = null ) {

        if( $can_cache ) 
        {
            $this->can_cache = $can_cache;
        }
        else
        {
            // Apply the admin setting to override the classes default...
        }
                
        if( $cache_time )
        {
            $this->cache_time = $cache_time;
        }
        else
        {
            // Apply the admin setting to override the classes default...
        }
                
        if( $can_queue )
        {
            $this->can_queue = $can_queue;
        }
        else
        {
            // Apply the admin setting to override the classes default...
        }
                               
        if( $user_specific )
        {
            $this->user_specific = $user_specific;
        }
        else
        {
            // Apply the admin setting to override the classes default...
        }
                
        if( $retry )
        {
            $this->retry = $retry;    
        }
        else
        {
            // Apply the admin setting to override the classes default...
        }
        
        // Values that will not have settings...
        $this->giving_user = $giving_user;
        $this->originating_function = $originating_function;
        $this->originating_line = $originating_line;           
    }
                        
    /**
    * Sets $this->call_parameters (try not to change) 
    * 
    * This method intends to finalize parameters for 
    * TwitchPress, WordPress and not just the Twitch API...
    * 
    * Some parameters may need to change such as pagination cursors but most
    * values should not change and instead use "new TwitchPress_Curl()" 
    * 
    * @param mixed $optional_args
    * @version 3.0
    */
    public function parse_arguments( $optional_args ) {
        
        // Apply the $optional_args but default to this classes in-line values...
        $this->call_parameters = wp_parse_args( $optional_args, array( 
                'type'              => $this->type,
                'endpoint'          => $this->endpoint,
                'can_cache'         => $this->can_cache,
                'cache_time'        => $this->cache_time,
                'can_queue'         => $this->can_queue,
                'api_name'          => $this->api_name,
                'giving_user'       => $this->giving_user,
                'current_user'      => $this->current_user,
                'user_specific'     => $this->user_specific,
                'retry'             => $this->retry,
                'file'              => $this->originating_line,
                'function'          => $this->originating_function,
                'line'              => $this->originating_line,
                'paginate'          => $this->paginate
            )
        );
              
        // Build the final request...
        $this->curl_request = array( 
            'headers'    => $this->headers, 
            'method'     => strtoupper( $this->type ), 
            'body'       => $this->curl_request_body,
            //'body'       => json_encode( $this->curl_request_body ),
            'user-agent' => 'curl/' . $this->curl_version['version'],
            'stream'     => false,
            'filename'   => false,
            'decompress' => false 
        );      
    }
    
    /**
    * Add new or over-write default headers...
    * 
    * @param mixed $new_headers
    * 
    * @version 2.0
    */
    public function add_headers( $new_headers = array() )  {
        if( !is_array( $this->headers ) ) {
            $this->headers = array();     
        } 
        $this->headers = array_merge( $this->headers, $new_headers );                 
    }

    /**                        
    * Check if there is a transient cache of the exact same call!
    * 
    * Use transients with care as they are not 100% matched. Requests should only
    * be cached when confident that the originating call does not change it's 
    * parameters/credentails frequently or is not a request for critical data
    * i.e. a general information or statistics update might be cached to avoid
    * too many requests. 
    * 
    * @version 2.0
    */
    public function get_transient() {
        // Create transient name using encoded values of the curl request.
        $prepend = $this->api_name;
        $append = twitchpress_encode_transient_name( $this->endpoint, $this->originating_function, $this->originating_line );
        $this->transient_name = 'TwitchPress_' . $prepend . '_' . $append;
        $trans_check = get_transient( $this->transient_name );
        if( $trans_check ) 
        {                        
            // We have a transient to rely on...
            $transient_value = get_transient( $this->transient_name );
            
            // We just need the original raw response and move forward as normal...
            $this->curl_reply_response = $transient_value['response'];
            
            return true;
        }    
        
        return false; 
    }
        
    /**
    * Queue the call...
    * 
    * @version 2.0
    */
    public function queue() {
        if( !$this->can_queue ) { return true; }  
        
        // Check for the transient that holds the raw response...
        $this->get_transient(); 
    }
    
    /**
    * Used by call_execute() and should be used right before any call...
    * 
    * @version 2.0
    */
    public function logging_initiate() {
        if( !TwitchPress_API_Logging::ready() ) { return; }

        // $entryid is returned by TwitchPress_API_Logging and held as $loggingid in this object...
        $this->loggingid = TwitchPress_API_Logging::new(
            $this->call_id, 
            'twitch',   
            $this->type, 
            86000,
            array(/*meta*/),
            '',
            4
        );
                           
        if( is_wp_error( $this->loggingid ) ) {
            error_log( __( 'Logging is failing in TwitchPress in function logging_initiate().', 'twitchpress' ) );    
        } else {
            TwitchPress_API_Logging::endpoint( 
                $this->loggingid,
                'api (determine api from endpoint)',
                $this->endpoint
            );
        }         
    }

    /**
    * Log a general error to the database...
    * 
    * @version 1.0
    */                                             
    public function logging_error( $code, $error, $meta = array() ) {
        if( !TwitchPress_API_Logging::ready() ) {return;} 
    
        $backtrace = debug_backtrace();
        
        TwitchPress_API_Logging::error( 
            $this->loggingid, 
            $code, 
            $error, 
            'unknown', 
            array( 
                'file'     => $backtrace[0]['file'],
                'function' => $backtrace[0]['function'],
                'line'     => $backtrace[0]['line']
            ) 
        );                        
    }
    
    /**
    * Use to soft-close a sequence of logging with the intention being to
    * update the original logging entry to indicate over-all Curl failure/success...
    * 
    * @version 1.0
    * 
    * @param mixed $outcome failed/success/rejected
    * @return mixed
    */
    public function logging_finalize( $outcome ) {      
        if( !TwitchPress_API_Logging::ready() ) {return;}  
        TwitchPress_API_Logging::end_logging( $this->loggingid, $outcome );    
    }
    
    /**
    * Make our calls to the API with looping for pagination included...
    * 
    * @version 3.0
    */
    public function call_execute() {    
          
        $this->logging_initiate();  
        
        $final_while = false;     
        $calls = 0; 
        $calls_failed = 0; // Failed pages will have a limit of retries...
        $calls_limit = 1; //Increase to a larger number for pagination 
 
        while( $final_while == false ) {
            ++$calls;

            $this->curl_reply = $this->WP_Http_Curl_Object->request( $this->endpoint, $this->curl_request );       

            // Log a WP error being returned by extracting error code and error message...
            if( is_wp_error( $this->curl_reply ) ) {
                $this->logging_finalize( 'failed' );
                $final_while = true;
                return $this->logging_error( $this->curl_reply->get_error_code(), $this->curl_reply->get_error_message() );    
            }
            
            // Store some common values in meta for all calls...
            TwitchPress_API_Logging::breakdown( $this->loggingid, $this->curl_reply );
            
            if( !isset( $this->curl_reply['response']['code'] ) ) {
                $this->logging_finalize( 'failed' );
                $final_while = true;
                return $this->logging_error( 'no response code', __( 'Curl reply does not include a response code.', 'twitchpress' ) );                
            }

            // Break the loop on reaching a strict limit of retries...
            if( $calls_failed >= TWITCHPRESS_RETRY_CALL_LIMIT ) { 
                $this->logging_error( 'retry limit reached', __( 'Pagination process was stopped before completion due to too many failed calls.', 'twitchpress' ) );
                $this->logging_finalize( 'failed' );
                break; 
            }
                        
            // Should this curl request be cached for debugging purposes?
            if( $this->can_cache )
            {
                $transient_value = array(
                    'curl_body'     => $this->curl_request_body,
                    'curl_request'  => $this->curl_request,
                    'curl_reply'    => $this->curl_reply
                );
                
                set_transient( $this->transient_name, $transient_value, $this->cache_time ); 
            } 

            // Decode raw body reply and keep in the curl object for immediate use...
            if( isset( $this->curl_reply['response']['code'] ) && $this->curl_reply['response']['code'] == 200 ) {
                if( isset( $this->curl_reply['body'] ) ) {
                    $this->curl_reply_body = json_decode( $this->curl_reply['body'] );
                }
            } 

            // Set response code and message...
            if( isset( $this->curl_reply['response']['code'] ) ) {
                $this->response_code = $this->curl_reply['response']['code'];
            }   
            
            if( isset( $this->curl_reply['response']['message'] ) ) {
                $this->response_message = $this->curl_reply['response']['message'];    
            }       
            
            // Prepare paginated data differently...
            if( $this->paginate && isset( $this->curl_reply_body->data ) ){ 
                $this->pagination_array[] = array(
                    'data' => $this->curl_reply_body->data,
                    'page' => $calls
                );    
                
                $rows = count( $this->curl_reply_body->data );
                
                // Finish here when we have the last page of records...
                if( $rows < 100 ) { 
                    $final_while = true; 
                    $this->logging_finalize( 'success' );
                    break;
                }
            } else {
                $final_while = true; // Pagination not required! 
            }
        }  
        
        $this->logging_finalize( 'success' );
    }  
              
    public function get_curl_request() {
        return $this->curl_request;
    }
    
    public function get_curl_request_body() {
        return $this->curl_request_body;
    }
    
    public function user_output() {
        
    }
    
    public function developer_output() {
        
    }
    
    public function get_decoded_body() {
        if( !$this->curl_reply_body ) { return false; }
        return $this->curl_reply_body;    
    }
    
    public function set_curl_body( array $body ) {
        $this->curl_request_body = $body;
    }
    
    public function get_call_id() {
        return $this->call_id;
    }
}